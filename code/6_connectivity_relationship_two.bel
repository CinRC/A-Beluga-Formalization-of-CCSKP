%%% Proof of Theorem 2.1(ii)

% In order to prove Theorem 2.1(ii) (given two connected proof keyed labels T1 and T2, there exist two
% connected transitions whose proof keyed labels are T1 and T2), we first address the base case where the
% label of T1 and T2 is not tau. In this scenario, we prove that the two searched transitions are actually
% two forward transitions, in which at least one of the sources is standard, and the path connecting them
% has at most length one.

% Proof keyed labels whose label is not tau
LF lab_not_tau: pr_lab → type =
  | nt_inp: lab T (inp _) → lab_not_tau T
  | nt_out: lab T (out _) → lab_not_tau T
;

% Type family encoding the existence of forward transitions in which at least one of the sources is standard
% and the path connecting them has at most length one. Additional information on the involved labels is included.
LF max_one_step: pr_lab → pr_lab → type =
  | c_id: std X1 → fstep X1 T1 X1' → fstep X1 T2 X2 → max_one_step T1 T2
  | c_fw: std X1 → fstep X1 T1 X1' → fstep X1 T3 X2' → fstep X2' T2 X2 → lab T1 L1 → lab T3 L1 → max_one_step T1 T2
  | c_bw: std X2' → fstep X1 T1 X1' → bstep X1 T3 X2' → fstep X2' T2 X2 → lab T2 L2 → lab T3 L2 → max_one_step T1 T2
;


% Proof of the base case of Theorem 2.1(ii)
rec conn_rel_two_base: (g:ctx) [g ⊢ valid T1] → [g ⊢ valid T2] → [g ⊢ conn T1 T2] →
  [g ⊢ lab_not_tau T1] → [g ⊢ lab_not_tau T2] → [g ⊢ max_one_step T1 T2] =
/ total c (conn_rel_two_base _ _ _ _ _ c _ _) /
fn v1,v2,c,n1,n2 ⇒ case c of
  | [g ⊢ c_a1] ⇒ let [g ⊢ rl D F]:[g ⊢ realised T2] = pr_lab_is_realised v2 in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T2] in
    let [g ⊢ H]:[g ⊢ key _ K[]] = [g ⊢ H] in
    let [g ⊢ ex_n I] = existence_of_different_key [g] [⊢ K] in
    [g ⊢ c_fw (std_pref D) (fs_pref D) (fs_pref D) (fs_kpref F H I) lab_base lab_base]
  | [g ⊢ c_a2] ⇒ let [g ⊢ rl D F]:[g ⊢ realised T1] = pr_lab_is_realised v1 in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T1] in
    let [g ⊢ H]:[g ⊢ key _ K[]] = [g ⊢ H] in
    let [g ⊢ ex_n I] = existence_of_different_key [g] [⊢ K] in
    [g ⊢ c_bw (std_pref D) (fs_kpref F H I) (bs_pref D) (fs_pref D) lab_base lab_base]
  | [g ⊢ c_c1l C] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in (case n1 of
       | [g ⊢ nt_inp (lab_suml L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_suml L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F3 std_null) (fs_suml F2 std_null) (lab_suml L1') (lab_suml L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum D std_null) (fs_suml F1 std_null) (bs_suml B3 std_null) (fs_suml F2 std_null) (lab_suml L2') (lab_suml L3')])
            | [g ⊢ nt_out (lab_suml L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F3 std_null) (fs_suml F2 std_null) (lab_suml L1') (lab_suml L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum D std_null) (fs_suml F1 std_null) (bs_suml B3 std_null) (fs_suml F2 std_null) (lab_suml L2') (lab_suml L3')]))
       | [g ⊢ nt_out (lab_suml L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_suml L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F3 std_null) (fs_suml F2 std_null) (lab_suml L1') (lab_suml L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum D std_null) (fs_suml F1 std_null) (bs_suml B3 std_null) (fs_suml F2 std_null) (lab_suml L2') (lab_suml L3')])
            | [g ⊢ nt_out (lab_suml L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum D std_null) (fs_suml F1 std_null) (fs_suml F3 std_null) (fs_suml F2 std_null) (lab_suml L1') (lab_suml L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum D std_null) (fs_suml F1 std_null) (bs_suml B3 std_null) (fs_suml F2 std_null) (lab_suml L2') (lab_suml L3')])))
  | [g ⊢ c_c1r C] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in (case n1 of
       | [g ⊢ nt_inp (lab_sumr L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_sumr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F3 std_null) (fs_sumr F2 std_null) (lab_sumr L1') (lab_sumr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum std_null D) (fs_sumr F1 std_null) (bs_sumr B3 std_null) (fs_sumr F2 std_null) (lab_sumr L2') (lab_sumr L3')])
            | [g ⊢ nt_out (lab_sumr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F3 std_null) (fs_sumr F2 std_null) (lab_sumr L1') (lab_sumr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum std_null D) (fs_sumr F1 std_null) (bs_sumr B3 std_null) (fs_sumr F2 std_null) (lab_sumr L2') (lab_sumr L3')]))
       | [g ⊢ nt_out (lab_sumr L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_sumr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F3 std_null) (fs_sumr F2 std_null) (lab_sumr L1') (lab_sumr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum std_null D) (fs_sumr F1 std_null) (bs_sumr B3 std_null) (fs_sumr F2 std_null) (lab_sumr L2') (lab_sumr L3')])
            | [g ⊢ nt_out (lab_sumr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F2 std_null)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ [g ⊢ c_fw (std_sum std_null D) (fs_sumr F1 std_null) (fs_sumr F3 std_null) (fs_sumr F2 std_null) (lab_sumr L1') (lab_sumr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ [g ⊢ c_bw (std_sum std_null D) (fs_sumr F1 std_null) (bs_sumr B3 std_null) (fs_sumr F2 std_null) (lab_sumr L2') (lab_sumr L3')])))
  | [g ⊢ c_c2l] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ c_id (std_sum D1 D2) (fs_suml F1 D2) (fs_sumr F2 D1)]
  | [g ⊢ c_c2r] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ c_id (std_sum D2 D1) (fs_sumr F1 D2) (fs_suml F2 D1)]
  | [g ⊢ c_p1l C] ⇒ let [g ⊢ v_parl V1]:[g ⊢ valid (pr_parl T1)] = v1 in
    let [g ⊢ v_parl V2]:[g ⊢ valid (pr_parl T2)] = v2 in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ std_null] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ std_null] in
    (case n1 of
       | [g ⊢ nt_inp (lab_parl L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_parl L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L1') (lab_parl L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par D std_null) (fs_parl F1 H1 N1) (bs_parl B3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L2') (lab_parl L3')])
            | [g ⊢ nt_out (lab_parl L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L1') (lab_parl L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par D std_null) (fs_parl F1 H1 N1) (bs_parl B3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L2') (lab_parl L3')]))
       | [g ⊢ nt_out (lab_parl L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_parl L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L1') (lab_parl L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par D std_null) (fs_parl F1 H1 N1) (bs_parl B3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L2') (lab_parl L3')])
            | [g ⊢ nt_out (lab_parl L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par D std_null) (fs_parl F1 H1 N1) (fs_parl F3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L1') (lab_parl L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par D std_null) (fs_parl F1 H1 N1) (bs_parl B3 H3 N3) (fs_parl F2 H2 N2) (lab_parl L2') (lab_parl L3')])))
  | [g ⊢ c_p1r C] ⇒ let [g ⊢ v_parr V1]:[g ⊢ valid (pr_parr T1)] = v1 in
    let [g ⊢ v_parr V2]:[g ⊢ valid (pr_parr T2)] = v2 in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ std_null] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ std_null] in
    (case n1 of
       | [g ⊢ nt_inp (lab_parr L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_parr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L1') (lab_parr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par std_null D) (fs_parr F1 H1 N1) (bs_parr B3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L2') (lab_parr L3')])
            | [g ⊢ nt_out (lab_parr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_inp L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L1') (lab_parr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par std_null D) (fs_parr F1 H1 N1) (bs_parr B3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L2') (lab_parr L3')]))
       | [g ⊢ nt_out (lab_parr L1)] ⇒ (case n2 of
            | [g ⊢ nt_inp (lab_parr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_inp L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L1') (lab_parr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par std_null D) (fs_parr F1 H1 N1) (bs_parr B3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L2') (lab_parr L3')])
            | [g ⊢ nt_out (lab_parr L2)] ⇒ (case conn_rel_two_base [g ⊢ V1] [g ⊢ V2] [g ⊢ C] [g ⊢ nt_out L1] [g ⊢ nt_out L2] of
                 | [g ⊢ c_id D F1 F2] ⇒ [g ⊢ c_id (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F2 H2 N2)]
                 | [g ⊢ c_fw D F1 F3 F2 L1' L3'] ⇒ let [g ⊢ _]:[g ⊢ fstep _ T3 _] = [g ⊢ F3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_fw (std_par std_null D) (fs_parr F1 H1 N1) (fs_parr F3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L1') (lab_parr L3')]
                 | [g ⊢ c_bw D F1 B3 F2 L2' L3'] ⇒ let [g ⊢ _]:[g ⊢ bstep _ T3 _] = [g ⊢ B3] in
                   let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ std_null] in
                   [g ⊢ c_bw (std_par std_null D) (fs_parr F1 H1 N1) (bs_parr B3 H3 N3) (fs_parr F2 H2 N2) (lab_parr L2') (lab_parr L3')])))
  | [g ⊢ c_p2l] ⇒ let [g ⊢ v_parl V1]:[g ⊢ valid (pr_parl T1)] = v1 in
    let [g ⊢ v_parr V2]:[g ⊢ valid (pr_parr T2)] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ D2] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ D1] in
    [g ⊢ c_id (std_par D1 D2) (fs_parl F1 H1 N1) (fs_parr F2 H2 N2)]
  | [g ⊢ c_p2r] ⇒ let [g ⊢ v_parr V1]:[g ⊢ valid (pr_parr T1)] = v1 in
    let [g ⊢ v_parl V2]:[g ⊢ valid (pr_parl T2)] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ D2] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ D1] in
    [g ⊢ c_id (std_par D2 D1) (fs_parr F1 H1 N1) (fs_parl F2 H2 N2)]
  | [g ⊢ c_s1l C] ⇒ (case n2 of
       | [g ⊢ nt_inp L] ⇒ impossible [g ⊢ L]
       | [g ⊢ nt_out L] ⇒ impossible [g ⊢ L])
  | [g ⊢ c_s1r C] ⇒ (case n2 of
       | [g ⊢ nt_inp L] ⇒ impossible [g ⊢ L]
       | [g ⊢ nt_out L] ⇒ impossible [g ⊢ L])
  | [g ⊢ c_s2l C] ⇒ (case n1 of
       | [g ⊢ nt_inp L] ⇒ impossible [g ⊢ L]
       | [g ⊢ nt_out L] ⇒ impossible [g ⊢ L])
  | [g ⊢ c_s2r C] ⇒ (case n1 of
       | [g ⊢ nt_inp L] ⇒ impossible [g ⊢ L]
       | [g ⊢ nt_out L] ⇒ impossible [g ⊢ L])
  | [g ⊢ c_s3 C1 C2] ⇒ (case n1 of
       | [g ⊢ nt_inp L] ⇒ impossible [g ⊢ L]
       | [g ⊢ nt_out L] ⇒ impossible [g ⊢ L])
;


% Type family encoding the existence of two forward transitions
% connected by a path and involving reachable processes
LF ex_conn_fstep: pr_lab → pr_lab → type =
  | ex_cf: fstep X1 T1 X1' → fstep X2' T2 X2 → step* X1 X2' → reachable X1 → ex_conn_fstep T1 T2
;

% We prove a stronger version of the second part of Theorem 2.1(ii):
% If two valid proof labels are connected, then there are forward transitions
% indexed by such proof keyed labels and connected by a path; moreover,
% the processes involved in such transitions are reachable.
rec conn_rel_two_fstep: (g:ctx) [g ⊢ valid T1] → [g ⊢ valid T2] → [g ⊢ conn T1 T2] → [g ⊢ ex_conn_fstep T1 T2] =
/ total c (conn_rel_two_fstep _ _ _ _ _ c) /
fn v1,v2,c ⇒ case c of
  | [g ⊢ c_a1] ⇒ let [g ⊢ rl D F]:[g ⊢ realised T2] = pr_lab_is_realised v2 in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T2] in
    let [g ⊢ H]:[g ⊢ key _ K[]] = [g ⊢ H] in
    let [g ⊢ ex_n I] = existence_of_different_key [g] [⊢ K] in
    [g ⊢ ex_cf (fs_pref D) (fs_kpref F H I) (st_s* (fw (fs_pref D))) (rch (std_pref D) id_s*)]
  | [g ⊢ c_a2] ⇒ let [g ⊢ rl D F]:[g ⊢ realised T1] = pr_lab_is_realised v1 in
    let [g ⊢ ex_k H] = existence_of_key [g ⊢ T1] in
    let [g ⊢ H]:[g ⊢ key _ K[]] = [g ⊢ H] in
    let [g ⊢ ex_n I] = existence_of_different_key [g] [⊢ K] in
    [g ⊢ ex_cf (fs_kpref F H I) (fs_pref D) (st_s* (bw (bs_pref D))) (rch (std_pref D) (st_s* (fw (fs_pref D))))]
  | [g ⊢ c_c1l C] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in
    let [g ⊢ ex_cf F1 F2 S* (rch D S0*)] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ V2] [g ⊢ C] in
    let [g ⊢ S*'] = step*_sumleft_null [g ⊢ S*] in
    let [g ⊢ S0*'] = step*_sumleft_null [g ⊢ S0*] in
    [g ⊢ ex_cf (fs_suml F1 std_null) (fs_suml F2 std_null) S*' (rch (std_sum D std_null) S0*')]
  | [g ⊢ c_c1r C] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in
    let [g ⊢ ex_cf F1 F2 S* (rch D S0*)] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ V2] [g ⊢ C] in
    let [g ⊢ S*'] = step*_sumright_null [g ⊢ S*] in
    let [g ⊢ S0*'] = step*_sumright_null [g ⊢ S0*] in
    [g ⊢ ex_cf (fs_sumr F1 std_null) (fs_sumr F2 std_null) S*' (rch (std_sum std_null D) S0*')]
  | [g ⊢ c_c2l] ⇒ let [g ⊢ v_suml V1] = v1 in
    let [g ⊢ v_sumr V2] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ ex_cf (fs_suml F1 D2) (fs_sumr F2 D1) id_s* (rch (std_sum D1 D2) id_s*)]
  | [g ⊢ c_c2r] ⇒ let [g ⊢ v_sumr V1] = v1 in
    let [g ⊢ v_suml V2] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    [g ⊢ ex_cf (fs_sumr F1 D2) (fs_suml F2 D1) id_s* (rch (std_sum D2 D1) id_s*)]
  | [g ⊢ c_p1l C] ⇒ let [g ⊢ v_parl V1] = v1 in
    let [g ⊢ v_parl V2] = v2 in
    let [g ⊢ ex_cf F1 F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 T2] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ V2] [g ⊢ C] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ std_null] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ std_null] in
    let [g ⊢ S*'] = step*_parleft_std [g ⊢ S*] [g ⊢ std_null] in
    let [g ⊢ S0*'] = step*_parleft_std [g ⊢ S0*] [g ⊢ std_null] in
    [g ⊢ ex_cf (fs_parl F1 H1 N1) (fs_parl F2 H2 N2) S*' (rch (std_par D std_null) S0*')]
  | [g ⊢ c_p1r C] ⇒ let [g ⊢ v_parr V1] = v1 in
    let [g ⊢ v_parr V2] = v2 in
    let [g ⊢ ex_cf F1 F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 T2] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ V2] [g ⊢ C] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ std_null] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ std_null] in
    let [g ⊢ S*'] = step*_parright_std [g ⊢ S*] [g ⊢ std_null] in
    let [g ⊢ S0*'] = step*_parright_std [g ⊢ S0*] [g ⊢ std_null] in
    [g ⊢ ex_cf (fs_parr F1 H1 N1) (fs_parr F2 H2 N2) S*' (rch (std_par std_null D) S0*')]
  | [g ⊢ c_p2l] ⇒ let [g ⊢ v_parl V1]:[g ⊢ valid (pr_parl T1)] = v1 in
    let [g ⊢ v_parr V2]:[g ⊢ valid (pr_parr T2)] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ D2] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ D1] in
    [g ⊢ ex_cf (fs_parl F1 H1 N1) (fs_parr F2 H2 N2) id_s* (rch (std_par D1 D2) id_s*)]
  | [g ⊢ c_p2r] ⇒ let [g ⊢ v_parr V1]:[g ⊢ valid (pr_parr T1)] = v1 in
    let [g ⊢ v_parl V2]:[g ⊢ valid (pr_parl T2)] = v2 in
    let [g ⊢ rl D1 F1] = pr_lab_is_realised [g ⊢ V1] in
    let [g ⊢ rl D2 F2] = pr_lab_is_realised [g ⊢ V2] in
    let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ D2] in
    let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ D1] in
    [g ⊢ ex_cf (fs_parr F1 H1 N1) (fs_parl F2 H2 N2) id_s* (rch (std_par D2 D1) id_s*)]
  | [g ⊢ c_s1l C] ⇒ let [g ⊢ v_parl V1] = v1 in (case v2 of
       | [g ⊢ v_synl VL VR LL HL LR HR] ⇒ let [g ⊢ rl DR FR] = pr_lab_is_realised [g ⊢ VR] in
         let [g ⊢ ex_cf F1 FL S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 _] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ VL] [g ⊢ C] in
         let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ DR] in
         let [g ⊢ S0*'] = step*_parleft_std [g ⊢ S0*] [g ⊢ DR] in
         let [g ⊢ S*'] = step*_parleft_std [g ⊢ S*] [g ⊢ DR] in
         [g ⊢ ex_cf (fs_parl F1 H1 N1) (fs_synl FL LL HL FR LR HR) S*' (rch (std_par D DR) S0*')]
       | [g ⊢ v_synr VL VR LL HL LR HR] ⇒ let [g ⊢ rl DR FR] = pr_lab_is_realised [g ⊢ VR] in
         let [g ⊢ ex_cf F1 FL S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 _] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ VL] [g ⊢ C] in
         let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ DR] in
         let [g ⊢ S0*'] = step*_parleft_std [g ⊢ S0*] [g ⊢ DR] in
         let [g ⊢ S*'] = step*_parleft_std [g ⊢ S*] [g ⊢ DR] in
         [g ⊢ ex_cf (fs_parl F1 H1 N1) (fs_synr FL LL HL FR LR HR) S*' (rch (std_par D DR) S0*')])
  | [g ⊢ c_s1r C] ⇒ let [g ⊢ v_parr V1] = v1 in (case v2 of
       | [g ⊢ v_synl VL VR LL HL LR HR] ⇒ let [g ⊢ rl DL FL] = pr_lab_is_realised [g ⊢ VL] in
         let [g ⊢ ex_cf F1 FR S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 _] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ VR] [g ⊢ C] in
         let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ DL] in
         let [g ⊢ S0*'] = step*_parright_std [g ⊢ S0*] [g ⊢ DL] in
         let [g ⊢ S*'] = step*_parright_std [g ⊢ S*] [g ⊢ DL] in
         [g ⊢ ex_cf (fs_parr F1 H1 N1) (fs_synl FL LL HL FR LR HR) S*' (rch (std_par DL D) S0*')]
       | [g ⊢ v_synr VL VR LL HL LR HR] ⇒ let [g ⊢ rl DL FL] = pr_lab_is_realised [g ⊢ VL] in
         let [g ⊢ ex_cf F1 FR S* (rch D S0*)]:[g ⊢ ex_conn_fstep T1 _] = conn_rel_two_fstep [g ⊢ V1] [g ⊢ VR] [g ⊢ C] in
         let [g ⊢ ex_kn _ H1 N1] = no_key_of_prlab_in_std [g ⊢ T1] [g ⊢ DL] in
         let [g ⊢ S0*'] = step*_parright_std [g ⊢ S0*] [g ⊢ DL] in
         let [g ⊢ S*'] = step*_parright_std [g ⊢ S*] [g ⊢ DL] in
         [g ⊢ ex_cf (fs_parr F1 H1 N1) (fs_synr FL LL HL FR LR HR) S*' (rch (std_par DL D) S0*')])
  | [g ⊢ c_s2l C] ⇒ let [g ⊢ v_parl V2] = v2 in (case v1 of
       | [g ⊢ v_synl VL VR LL HL LR HR] ⇒ let [g ⊢ rl DR FR] = pr_lab_is_realised [g ⊢ VR] in
         let [g ⊢ ex_cf FL F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep _ T2] = conn_rel_two_fstep [g ⊢ VL] [g ⊢ V2] [g ⊢ C] in
         let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ DR] in
         let [g ⊢ S0*'] = step*_parleft_std [g ⊢ S0*] [g ⊢ DR] in
         let [g ⊢ S*'] = step*_parleft_std [g ⊢ S*] [g ⊢ DR] in
         [g ⊢ ex_cf (fs_synl FL LL HL FR LR HR) (fs_parl F2 H2 N2) S*' (rch (std_par D DR) S0*')]
       | [g ⊢ v_synr VL VR LL HL LR HR] ⇒ let [g ⊢ rl DR FR] = pr_lab_is_realised [g ⊢ VR] in
         let [g ⊢ ex_cf FL F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep _ T2] = conn_rel_two_fstep [g ⊢ VL] [g ⊢ V2] [g ⊢ C] in
         let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ DR] in
         let [g ⊢ S0*'] = step*_parleft_std [g ⊢ S0*] [g ⊢ DR] in
         let [g ⊢ S*'] = step*_parleft_std [g ⊢ S*] [g ⊢ DR] in
         [g ⊢ ex_cf (fs_synr FL LL HL FR LR HR) (fs_parl F2 H2 N2) S*' (rch (std_par D DR) S0*')])
  | [g ⊢ c_s2r C] ⇒ let [g ⊢ v_parr V2] = v2 in (case v1 of
       | [g ⊢ v_synl VL VR LL HL LR HR] ⇒ let [g ⊢ rl DL FL] = pr_lab_is_realised [g ⊢ VL] in
         let [g ⊢ ex_cf FR F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep _ T2] = conn_rel_two_fstep [g ⊢ VR] [g ⊢ V2] [g ⊢ C] in
         let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ DL] in
         let [g ⊢ S0*'] = step*_parright_std [g ⊢ S0*] [g ⊢ DL] in
         let [g ⊢ S*'] = step*_parright_std [g ⊢ S*] [g ⊢ DL] in
         [g ⊢ ex_cf (fs_synl FL LL HL FR LR HR) (fs_parr F2 H2 N2) S*' (rch (std_par DL D) S0*')]
       | [g ⊢ v_synr VL VR LL HL LR HR] ⇒ let [g ⊢ rl DL FL] = pr_lab_is_realised [g ⊢ VL] in
         let [g ⊢ ex_cf FR F2 S* (rch D S0*)]:[g ⊢ ex_conn_fstep _ T2] = conn_rel_two_fstep [g ⊢ VR] [g ⊢ V2] [g ⊢ C] in
         let [g ⊢ ex_kn _ H2 N2] = no_key_of_prlab_in_std [g ⊢ T2] [g ⊢ DL] in
         let [g ⊢ S0*'] = step*_parright_std [g ⊢ S0*] [g ⊢ DL] in
         let [g ⊢ S*'] = step*_parright_std [g ⊢ S*] [g ⊢ DL] in
         [g ⊢ ex_cf (fs_synr FL LL HL FR LR HR) (fs_parr F2 H2 N2) S*' (rch (std_par DL D) S0*')])
  | [g ⊢ c_s3 C1 C2] ⇒ (case v1 of
       | [g ⊢ v_synl VL1 VR1 LL1 HL1 LR1 HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 LL2 HL2 LR2 HR2] ⇒ 
              let [g ⊢ E1] = conn_rel_two_base [g ⊢ VL1] [g ⊢ VL2] [g ⊢ C1] [g ⊢ nt_inp LL1] [g ⊢ nt_inp LL2] in
              let [g ⊢ E2] = conn_rel_two_base [g ⊢ VR1] [g ⊢ VR2] [g ⊢ C2] [g ⊢ nt_out LR1] [g ⊢ nt_out LR2] in
              (case [g ⊢ E1] of
                 | [g ⊢ c_id DL FL1 FL2] ⇒ (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) id_s* (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parr FR3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parr BR3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 H3 N3))))])
                 | [g ⊢ c_fw DL FL1 FL3 FL2 LL1' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = [g ⊢ FL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parl FL3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 LR1' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL1] [g ⊢ LL1'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR1] [g ⊢ LR1'] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_synl FL3 LL3 HL3 FR3 LR3 HR3))) (rch (std_par DL DR) id_s*)]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) id_s*)])
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (fw (fs_parl FL3 HL3 NL3)))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 HR3 NR3))))])
                 | [g ⊢ c_bw DL FL1 BL3 FL2 LL2' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = loop_lemma_two [g ⊢ BL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parl BL3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 H3 N3))))]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parl BL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 HL3 NL3))))]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 LR2' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL2] [g ⊢ LL2'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR2] [g ⊢ LR2'] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_synl BL3 LL3 HL3 BR3 LR3 HR3))) (rch (std_par DL DR) (st_s* (fw (fs_synl FL3 LL3 HL3 FR3 LR3 HR3))))]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (bw (bs_parl BL3 HL3 NL3)))) (rch (std_par DL DR) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))))])))
            | [g ⊢ v_synr VL2 VR2 LL2 HL2 LR2 HR2] ⇒
              let [g ⊢ E1] = conn_rel_two_base [g ⊢ VL1] [g ⊢ VL2] [g ⊢ C1] [g ⊢ nt_inp LL1] [g ⊢ nt_out LL2] in
              let [g ⊢ E2] = conn_rel_two_base [g ⊢ VR1] [g ⊢ VR2] [g ⊢ C2] [g ⊢ nt_out LR1] [g ⊢ nt_inp LR2] in
              (case [g ⊢ E1] of
                 | [g ⊢ c_id DL FL1 FL2] ⇒ (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) id_s* (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parr FR3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parr BR3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 H3 N3))))])
                 | [g ⊢ c_fw DL FL1 FL3 FL2 LL1' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = [g ⊢ FL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parl FL3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 LR1' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL1] [g ⊢ LL1'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR1] [g ⊢ LR1'] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_synl FL3 LL3 HL3 FR3 LR3 HR3))) (rch (std_par DL DR) id_s*)]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) id_s*)])
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (fw (fs_parl FL3 HL3 NL3)))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 HR3 NR3))))])
                 | [g ⊢ c_bw DL FL1 BL3 FL2 LL2' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = loop_lemma_two [g ⊢ BL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parl BL3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 H3 N3))))]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parl BL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 HL3 NL3))))]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 LR2' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL2] [g ⊢ LL2'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR2] [g ⊢ LR2'] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_synr BL3 LL3 HL3 BR3 LR3 HR3))) (rch (std_par DL DR) (st_s* (fw (fs_synr FL3 LL3 HL3 FR3 LR3 HR3))))]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synl FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (bw (bs_parl BL3 HL3 NL3)))) (rch (std_par DL DR) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))))]))))
       | [g ⊢ v_synr VL1 VR1 LL1 HL1 LR1 HR1] ⇒ (case v2 of
            | [g ⊢ v_synl VL2 VR2 LL2 HL2 LR2 HR2] ⇒
              let [g ⊢ E1] = conn_rel_two_base [g ⊢ VL1] [g ⊢ VL2] [g ⊢ C1] [g ⊢ nt_out LL1] [g ⊢ nt_inp LL2] in
              let [g ⊢ E2] = conn_rel_two_base [g ⊢ VR1] [g ⊢ VR2] [g ⊢ C2] [g ⊢ nt_inp LR1] [g ⊢ nt_out LR2] in
              (case [g ⊢ E1] of
                 | [g ⊢ c_id DL FL1 FL2] ⇒ (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) id_s* (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parr FR3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parr BR3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 H3 N3))))])
                 | [g ⊢ c_fw DL FL1 FL3 FL2 LL1' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = [g ⊢ FL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parl FL3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 LR1' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL1] [g ⊢ LL1'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR1] [g ⊢ LR1'] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_synr FL3 LL3 HL3 FR3 LR3 HR3))) (rch (std_par DL DR) id_s*)]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) id_s*)])
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (fw (fs_parl FL3 HL3 NL3)))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 HR3 NR3))))])
                 | [g ⊢ c_bw DL FL1 BL3 FL2 LL2' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = loop_lemma_two [g ⊢ BL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parl BL3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 H3 N3))))]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parl BL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 HL3 NL3))))]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 LR2' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL2] [g ⊢ LL2'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR2] [g ⊢ LR2'] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_synl BL3 LL3 HL3 BR3 LR3 HR3))) (rch (std_par DL DR) (st_s* (fw (fs_synl FL3 LL3 HL3 FR3 LR3 HR3))))]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synl FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (bw (bs_parl BL3 HL3 NL3)))) (rch (std_par DL DR) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))))])))
            | [g ⊢ v_synr VL2 VR2 LL2 HL2 LR2 HR2] ⇒
              let [g ⊢ E1] = conn_rel_two_base [g ⊢ VL1] [g ⊢ VL2] [g ⊢ C1] [g ⊢ nt_out LL1] [g ⊢ nt_out LL2] in
              let [g ⊢ E2] = conn_rel_two_base [g ⊢ VR1] [g ⊢ VR2] [g ⊢ C2] [g ⊢ nt_inp LR1] [g ⊢ nt_inp LR2] in
              (case [g ⊢ E1] of
                 | [g ⊢ c_id DL FL1 FL2] ⇒ (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) id_s* (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parr FR3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒ let [g ⊢ FR3]:[g ⊢ fstep _ T3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ T3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parr BR3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 H3 N3))))])
                 | [g ⊢ c_fw DL FL1 FL3 FL2 LL1' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = [g ⊢ FL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_parl FL3 H3 N3))) (rch (std_par DL DR) id_s*)]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 LR1' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL1] [g ⊢ LL1'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR1] [g ⊢ LR1'] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (fw (fs_synr FL3 LL3 HL3 FR3 LR3 HR3))) (rch (std_par DL DR) id_s*)]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) id_s*)])
                      | [g ⊢ c_bw DR FR1 BR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (fw (fs_parl FL3 HL3 NL3)))) (rch (std_par DL DR) (st_s* (fw (fs_parr FR3 HR3 NR3))))])
                 | [g ⊢ c_bw DL FL1 BL3 FL2 LL2' LL3] ⇒ let [g ⊢ FL3]:[g ⊢ fstep _ TL3 _] = loop_lemma_two [g ⊢ BL3] in
                   (case [g ⊢ E2] of
                      | [g ⊢ c_id DR FR1 FR2] ⇒
                        let [g ⊢ ex_kn _ H3 N3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_parl BL3 H3 N3))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 H3 N3))))]
                      | [g ⊢ c_fw DR FR1 FR3 FR2 _ _] ⇒
                        let [g ⊢ ex_kn _ HL3 NL3] = no_key_of_prlab_in_std [g ⊢ TL3] [g ⊢ DR] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = [g ⊢ FR3] in
                        let [g ⊢ ex_kn _ HR3 NR3] = no_key_of_prlab_in_std [g ⊢ TR3] [g ⊢ DL] in
                        [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parl BL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))) (rch (std_par DL DR) (st_s* (fw (fs_parl FL3 HL3 NL3))))]
                      | [g ⊢ c_bw DR FR1 BR3 FR2 LR2' LR3] ⇒
                        let [g ⊢ ex_k HL3] = existence_of_key [g ⊢ TL3] in
                        let [g ⊢ HL3]:[g ⊢ key _ KL3[]] = [g ⊢ HL3] in
                        let [g ⊢ FR3]:[g ⊢ fstep _ TR3 _] = loop_lemma_two [g ⊢ BR3] in
                        let [g ⊢ ex_k HR3] = existence_of_key [g ⊢ TR3] in
                        let [g ⊢ HR3]:[g ⊢ key _ KR3[]] = [g ⊢ HR3] in
                        (case compare [g] [⊢ KL3] [⊢ KR3] of
                           | [g ⊢ c_eq] ⇒
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LL2] [g ⊢ LL2'] in
                             let [g ⊢ refl] = uniqueness_of_lab [g ⊢ LR2] [g ⊢ LR2'] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (st_s* (bw (bs_synr BL3 LL3 HL3 BR3 LR3 HR3))) (rch (std_par DL DR) (st_s* (fw (fs_synr FL3 LL3 HL3 FR3 LR3 HR3))))]
                           | [g ⊢ c_neq I3] ⇒
                             let [g ⊢ NL3] = no_key_in_std [⊢ KL3] [g ⊢ DR] in
                             let [g ⊢ NR3] = lemma_fstep_std [g ⊢ DL] [g ⊢ FL3] [g ⊢ HL3] [g ⊢ I3] in
                             [g ⊢ ex_cf (fs_synr FL1 LL1 HL1 FR1 LR1 HR1) (fs_synr FL2 LL2 HL2 FR2 LR2 HR2) (tr_s* (st_s* (bw (bs_parr BR3 HR3 NR3))) (st_s* (bw (bs_parl BL3 HL3 NL3)))) (rch (std_par DL DR) (tr_s* (st_s* (fw (fs_parl FL3 HL3 NL3))) (st_s* (fw (fs_parr FR3 HR3 NR3)))))])))))
;

% We finally prove the second part of Theorem 2.1(ii) as a corollary of the previous theorem.

% Type family encoding the existence of two connected transitions involving reachable processes
LF ex_conn_tr: pr_lab → pr_lab → type =
  | ex_c: {S1: step X T1 X'} {S2: step Y T2 Y'} reachable X → conn_tr S1 S2 → ex_conn_tr T1 T2
;

% Proof of Theorem 2.1(ii) - second part:
% If two good proof labels are connected, then there are connected transitions with such labels.
rec conn_rel_two: (g:ctx) [g ⊢ valid T1] → [g ⊢ valid T2] → [g ⊢ conn T1 T2] → [g ⊢ ex_conn_tr T1 T2] =
/ total c (conn_rel_two _ _ _ _ _ c) /
fn v1,v2,c ⇒
let [g ⊢ ex_cf F1 F2 S* (rch D S0*)] = conn_rel_two_fstep v1 v2 c in
let [g ⊢ B2] = loop_lemma_one [g ⊢ F2] in
[g ⊢ ex_c (fw F1) (bw B2) (rch D S0*) (ct (fw F1) (bw B2) S*)]
;